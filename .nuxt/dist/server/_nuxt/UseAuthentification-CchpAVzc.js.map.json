{"file":"UseAuthentification-CchpAVzc.js","mappings":"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","names":["addError","axios"],"sources":["../../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../constants/errorMessages.ts","../../../../utils/errorToaster.ts","../../../../composables/UseAuthentification.ts"],"sourcesContent":["import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useServerHead } from \"@unhead/vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nexport function useRequestEvent(nuxtApp = useNuxtApp()) {\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useServerHead({\n    script: [{\n      key: vm && key ? key : code,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? window.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    } else {\n      callback();\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","export const ERROR_MESSAGES = {\n  'email already exists': \"L'adresse e-mail est déjà utilisée.\",\n  'The password field format is invalid': 'Le format du champ mot de passe est invalide.',\n  'The confirmPassword field and password field must be the same':\n    'Le champ de confirmation du mot de passe et le champ mot de passe doivent être identiques.',\n  'The username field must be defined': 'Le champ nom d’utilisateur doit être défini.',\n  'The email field must be defined': \"Le champ d'adresse e-mail doit être défini.\",\n  'The password field must be defined': 'Le champ mot de passe doit être défini.',\n  'The email field must be a valid email address':\n    \"Le champ d'adresse e-mail doit être une adresse e-mail valide.\",\n  'User not found or invalid': 'Utilisateur non trouvé ou invalide.',\n  'The email has already been taken': \"L'adresse e-mail a déjà été prise.\",\n};\n","import { ERROR_MESSAGES } from '~/constants/errorMessages';\nimport type { errorDetail, ServerError } from '~/models/errorModel';\n\nconst errorMessageArray = ref<errorDetail[]>([]);\n\nconst addError = (error: ServerError) => {\n  if ('errors' in error && Array.isArray(error.errors)) {\n    error.errors.forEach((err: errorDetail) => {\n      const parsedError = {\n        id: Date.now() + Math.random(),\n        ...err,\n        message: ERROR_MESSAGES[err.message as keyof typeof ERROR_MESSAGES] || err.message,\n      };\n      errorMessageArray.value.push(parsedError);\n\n      setTimeout(() => {\n        errorMessageArray.value = errorMessageArray.value.filter((e) => e.id !== parsedError.id);\n      }, 5000);\n    });\n  } else if ('message' in error) {\n    const parsedError = {\n      id: Date.now() + Math.random(),\n      message: ERROR_MESSAGES[error.message as keyof typeof ERROR_MESSAGES] || error.message,\n    };\n    errorMessageArray.value = [parsedError];\n\n    setTimeout(() => {\n      errorMessageArray.value = [];\n    }, 5000);\n  } else {\n    console.warn(\"Format d'erreur non supporté:\", error);\n  }\n};\n\nexport const useErrorToaster = () => {\n  return {\n    errorMessageArray,\n    addError,\n  };\n};\n","import type { AuthentificationModel } from '~/models/authentification/authentificationModel';\nimport type { errorModel } from '~/models/errorModel';\nimport type { RegisterModel } from '../models/authentification/registerModel';\n\nexport const useAuthentification = () => {\n  const config = useRuntimeConfig();\n  const router = useRouter();\n  const { addError } = useErrorToaster();\n\n  const sendRegister = async (registerInfo: RegisterModel): Promise<void> => {\n    try {\n      const { data } = await axios.post(`${config.public.apiUrl}/auth/register`, registerInfo);\n      return data;\n    } catch (error: unknown) {\n      addError(error as errorModel);\n    }\n  };\n\n  const sendLogin = async (authentification: AuthentificationModel) => {\n    try {\n      const { data } = await axios.post(`${config.public.apiUrl}/auth/login`, authentification);\n      if (data?.token?.token) {\n        const token = useCookie('token', {\n          maxAge: 60 * 60 * 24 * 30,\n          path: '/',\n          sameSite: 'strict',\n          secure: true,\n        });\n        token.value = data.token;\n        return data;\n      }\n    } catch (error: unknown) {\n      addError(error as errorModel);\n    }\n  };\n\n  const checkEmail = async (token: string) => {\n    try {\n      const { data } = await axios.get(`${config.public.apiUrl}/auth/verify-email/${token}`);\n      if (data) {\n        return data;\n      }\n    } catch (error: unknown) {\n      addError(error as errorModel);\n    }\n  };\n\n  const sendLogout = async () => {\n    try {\n      const token = useCookie('token');\n      const { data } = await axios.post(`${config.public.apiUrl}/auth/logout`, null, {\n        headers: {\n          Authorization: `Bearer  ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      if (data) {\n        await router.push('/');\n      }\n    } catch (error: unknown) {\n      addError(error as errorModel);\n    }\n  };\n\n  return { sendRegister, sendLogin, sendLogout, checkEmail };\n};\n"],"version":3}